# Layered Architecture - Week 4 Reflection

## 1. สิ่งที่เรียนรู้

ในสัปดาห์นี้ ผมได้เรียนรู้ว่า **Layered Architecture** เป็นการจัดโครงสร้างโปรเจกต์ให้ชัดเจนโดยแยกหน้าที่ของแต่ละส่วนออกจากกัน เช่น **Controller, Service, Model**

* Controller จัดการรับ request และ response
* Service จัดการ business logic
* Model จัดการข้อมูลและ database

การแยก Layer ทำให้โค้ด **อ่านง่าย แก้ไขง่าย และสามารถทดสอบแยกส่วนได้**

## 2. ข้อดีที่พบจากการทำจริง

* สามารถ **เพิ่มฟีเจอร์ใหม่** โดยแก้ไขเฉพาะ Layer ที่เกี่ยวข้อง เช่น การ assign task หรือ validation logic
* การทำ **Unit Test** เป็นเรื่องง่าย เพราะ logic แต่ละ Layer แยกออกชัดเจน
* ลดความเสี่ยงในการแก้ไขโค้ด เพราะไม่กระทบ Layer อื่น

## 3. ความท้าทายที่พบ

* การเข้าใจ flow ของโปรแกรมต้องเรียนรู้หลาย Layer
* ต้อง **จัดการการ import/export** ระหว่างไฟล์หลายไฟล์
* วิธีแก้: วางแผน structure ของโปรเจกต์ล่วงหน้า และสร้างไฟล์ตัวอย่างของแต่ละ Layer ก่อนเริ่มเขียนฟีเจอร์จริง

## 4. การจัดโครงสร้างโค้ด

การแบ่ง Layer ช่วยให้การจัดโครงสร้างโค้ดดีขึ้นอย่างมากเมื่อเทียบกับสัปดาห์ที่ 3 (Monolithic)

* โค้ดไม่ถูกรวมในไฟล์เดียว ทำให้ **อ่านง่าย แก้ไขง่าย และไม่ซ้ำซ้อน**
* สามารถ **ระบุหน้าที่ของแต่ละ Layer** ได้ชัดเจน เช่น แก้ไข validation logic แค่ Service Layer ไม่กระทบ Controller

## 5. เมื่อไหร่ควรใช้ Layered Architecture

* โปรเจกต์ **ขนาดกลางถึงใหญ่** (>1000 บรรทัด)
* ทีม **3 คนขึ้นไป** ที่ต้องทำงานพร้อมกัน
* ต้องการ **maintainability, testability และ scalability**
* แอปที่ต้องขยายต่อเนื่องในอนาคต หรือมีโอกาสเปลี่ยนเทคโนโลยี เช่น Database

## 6. การวิเคราะห์ Trade-offs

### ข้อดี

* Maintainability สูง แก้ไขฟีเจอร์ง่ายและปลอดภัย
* Testability ดี สามารถ Unit Test Layer แยกส่วน
* Reusability ดี สามารถนำฟังก์ชันหรือ Service ไปใช้ซ้ำ

### ข้อเสีย

* Complexity เพิ่มขึ้น ต้องเข้าใจ flow หลาย Layer
* Overhead เล็กน้อยจากการเรียก function ข้าม Layer
* เริ่มต้นพัฒนาอาจช้ากว่า Monolithic

### การประเมินโดยรวม

Layered Architecture แม้จะเพิ่มความซับซ้อนเล็กน้อย แต่ **คุ้มค่ากับ maintainability, testability และ scalability**
เหมาะสำหรับโปรเจกต์ที่ทีมใหญ่ หรือโปรเจกต์ที่จะพัฒนาต่อเนื่อง
สำหรับโปรเจกต์เล็กหรือทำคนเดียว Monolithic อาจเริ่มเร็วกว่า แต่เสียความชัดเจนและความง่ายในการบำรุงรักษา
